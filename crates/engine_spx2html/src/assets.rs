// Copyright 2022 the Tectonic Project
// Licensed under the MIT License.

//! Assets generated by a Tectonic HTML build.

use serde::Serialize;
use std::{
    collections::HashMap,
    fs::File,
    io::{Read, Write},
    path::Path,
};
use tectonic_errors::prelude::*;
use tectonic_status_base::tt_warning;

use crate::{fontfamily::FontEnsemble, specials::Special, Common};

/// Runtime state about which non-font assets have been created.
#[derive(Debug, Default)]
pub(crate) struct Assets {
    paths: HashMap<String, AssetOrigin>,
}

/// Different kinds of non-font assets that can be defined at runtime.
#[derive(Debug)]
enum AssetOrigin {
    /// Copy a file from the source stack directly to the output directory.
    Copy(String),

    /// Emit a CSS file containing information about the ensemble of fonts
    /// that have been used.
    FontCss,
}

impl Assets {
    /// Returns true if the special was successfully handled. The false case
    /// doesn't distinguish between a special that wasn't relevant, and one that
    /// was malformatted or otherwise unparseable.
    pub fn try_handle_special(&mut self, special: Special, common: &mut Common) -> bool {
        match special {
            Special::ProvideFile(spec) => {
                let (src_tex_path, dest_path) = match spec.split_once(' ') {
                    Some(t) => t,
                    None => {
                        tt_warning!(common.status, "ignoring malformatted special `{}`", special);
                        return false;
                    }
                };

                self.copy_file(src_tex_path, dest_path);
                true
            }

            Special::ProvideSpecial(spec) => {
                let (kind, dest_path) = match spec.split_once(' ') {
                    Some(t) => t,
                    None => {
                        tt_warning!(common.status, "ignoring malformatted special `{}`", special);
                        return false;
                    }
                };

                match kind {
                    "font-css" => {
                        self.emit_font_css(dest_path);
                        true
                    }
                    _ => {
                        tt_warning!(common.status, "ignoring unsupported special `{}`", special);
                        false
                    }
                }
            }

            _ => false,
        }
    }

    fn copy_file<S1: ToString, S2: ToString>(&mut self, src_path: S1, dest_path: S2) {
        self.paths.insert(
            dest_path.to_string(),
            AssetOrigin::Copy(src_path.to_string()),
        );
    }

    fn emit_font_css<S: ToString>(&mut self, dest_path: S) {
        self.paths
            .insert(dest_path.to_string(), AssetOrigin::FontCss);
    }

    pub(crate) fn emit(mut self, mut fonts: FontEnsemble, common: &mut Common) -> Result<()> {
        let faces = fonts.emit(common.out_base)?;

        for (dest_path, origin) in self.paths.drain() {
            match origin {
                AssetOrigin::Copy(ref src_path) => emit_copied_file(src_path, &dest_path, common),
                AssetOrigin::FontCss => emit_font_css(&dest_path, &faces, common),
            }?;
        }

        Ok(())
    }

    pub(crate) fn into_serialize(mut self, fonts: FontEnsemble) -> impl Serialize {
        let (mut assets, css_data) = fonts.into_serialize();

        for (dest_path, origin) in self.paths.drain() {
            let info = match origin {
                AssetOrigin::Copy(src_path) => syntax::AssetOrigin::Copy(src_path),
                AssetOrigin::FontCss => syntax::AssetOrigin::FontCss(css_data.clone()),
            };
            assets.insert(dest_path, info);
        }

        assets
    }
}

fn emit_copied_file(src_tex_path: &str, dest_path: &str, common: &mut Common) -> Result<()> {
    // Set up input?

    let mut ih = atry!(
        common.hooks.io().input_open_name(src_tex_path, common.status).must_exist();
        ["unable to open provideFile source `{}`", &src_tex_path]
    );

    // Set up output? TODO: create parent directories!

    let mut out_path = common.out_base.to_owned();

    for piece in dest_path.split('/') {
        if piece.is_empty() {
            continue;
        }

        if piece == ".." {
            bail!(
                "illegal provideFile dest path `{}`: it contains a `..` component",
                &dest_path
            );
        }

        let as_path = Path::new(piece);

        if as_path.is_absolute() || as_path.has_root() {
            bail!(
                "illegal provideFile path `{}`: it contains an absolute/rooted component",
                &dest_path,
            );
        }

        out_path.push(piece);
    }

    // Copy!

    {
        let mut out_file = atry!(
            File::create(&out_path);
            ["cannot open output file `{}`", out_path.display()]
        );

        atry!(
            std::io::copy(&mut ih, &mut out_file);
            ["cannot copy to output file `{}`", out_path.display()]
        );
    }

    // All done.

    let (name, digest_opt) = ih.into_name_digest();
    common
        .hooks
        .event_input_closed(name, digest_opt, common.status);
    Ok(())
}

fn emit_font_css(dest_path: &str, faces: &str, common: &mut Common) -> Result<()> {
    let mut out_path = common.out_base.to_owned();

    for piece in dest_path.split('/') {
        if piece.is_empty() {
            continue;
        }

        if piece == ".." {
            bail!(
                "illegal provideFile dest path `{}`: it contains a `..` component",
                &dest_path
            );
        }

        let as_path = Path::new(piece);

        if as_path.is_absolute() || as_path.has_root() {
            bail!(
                "illegal provideFile path `{}`: it contains an absolute/rooted component",
                &dest_path,
            );
        }

        out_path.push(piece);
    }

    // Write

    let mut out_file = atry!(
        File::create(&out_path);
        ["cannot open output file `{}`", out_path.display()]
    );

    atry!(
        write!(&mut out_file, "{}", faces);
        ["cannot write output file `{}`", out_path.display()]
    );

    Ok(())
}

/// Information about assets that have been defined in an SPX-to-HTML run.
#[derive(Debug, Default)]
pub struct AssetSpecification(syntax::Assets);

impl AssetSpecification {
    /// Update this specification with information from one that's been
    /// serialized.
    ///
    /// It is possible for two specifications to be incompatible, in which case
    /// an error will be returned and this object will be left in an undefined
    /// state.
    pub fn add_from_saved<R: Read>(&mut self, reader: R) -> Result<&mut Self> {
        let new: syntax::Assets = atry!(
            serde_json::from_reader(reader);
            ["failed to deserialize saved specification"]
        );

        // As things are currently structured, we can parse the new entries in
        // any order. This is because we assume that the both inputs (self and
        // the new one) have internally-consistent cross-referencing, in which
        // case their merger must as well. (Here, "cross-referencing" means
        // aspects like the font-family information referencing output filenames
        // for font-files.)

        use syntax::AssetOrigin as AO;

        for (path, new_origin) in &new {
            if let Some(cur_origin) = self.0.get_mut(path) {
                match (new_origin, cur_origin) {
                    (AO::Copy(new_src), AO::Copy(cur_src)) => {
                        if cur_src != new_src {
                            bail!(
                                "disagreeing sources `{}` and `{}` for copied output asset `{}`",
                                cur_src,
                                new_src,
                                path
                            );
                        }
                    }

                    (AO::FontFile(new_ff), AO::FontFile(cur_ff)) => {
                        if new_ff.source != cur_ff.source {
                            bail!(
                                "disagreeing sources `{}` and `{}` for output font asset `{}`",
                                cur_ff.source,
                                new_ff.source,
                                path
                            );
                        }

                        // We have two font assets with the same source. We need
                        // to merge the vglyph information, but otherwise we're
                        // good!
                        syntax::merge_vglyphs(&mut cur_ff.vglyphs, &new_ff.vglyphs);
                    }

                    (AO::FontCss(new_fe), AO::FontCss(cur_fe)) => {
                        // We have two font ensembles. Try merging.
                        syntax::merge_font_ensembles(cur_fe, new_fe)?;
                    }

                    (new2, cur2) => {
                        bail!(
                            "disagreeing origin types {} and {} for output asset `{}`",
                            cur2,
                            new2,
                            path
                        );
                    }
                }
            } else {
                // This path is undefined in the current object. Just add it!
                self.0.insert(path.clone(), new_origin.clone());
            }
        }

        Ok(self)
    }

    /// Save this asset specification to a stream.
    ///
    /// Currently, this is done in a JSON format, but this is not guaranteed to
    /// always be the case. The serialization format does not make any effort to
    /// provide for backwards or forwards compatibility. The serialized data
    /// should be viewed as ephemera that are only guaranteed to remain useful
    /// so long as the executing program remains unchanged.
    pub fn save<W: Write>(&self, writer: W) -> Result<()> {
        serde_json::to_writer_pretty(writer, &self.0).map_err(|e| e.into())
    }
}

/// The concrete syntax for saving asset-output state, wired up via serde.
///
/// The top-level type is Assets.
pub(crate) mod syntax {
    use serde::{Deserialize, Serialize};
    use std::collections::HashMap;
    use tectonic_errors::prelude::*;

    use crate::fontfile::GlyphId;

    pub type Assets = HashMap<String, AssetOrigin>;

    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "kind")]
    pub enum AssetOrigin {
        /// Copy a file from the source stack directly to the output directory.
        Copy(String),

        /// Emit a CSS file containing information about the ensemble of fonts
        /// that have been used.
        FontCss(FontEnsembleAssetData),

        /// An OpenType/TrueType font file and variants with customized CMAP tables
        /// allowing access to unusual glyphs.
        FontFile(FontFileAssetData),
    }

    impl std::fmt::Display for AssetOrigin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
            match self {
                AssetOrigin::Copy(src) => write!(f, "copy out `{}`", src),

                AssetOrigin::FontCss(fe) => {
                    let mut first = true;

                    write!(f, "CSS for font faces")?;

                    for facename in fe.keys() {
                        if first {
                            write!(f, " ")?;
                            first = false;
                        } else {
                            write!(f, ", ")?;
                        }

                        write!(f, "\"{}\"", facename)?;
                    }

                    Ok(())
                }

                AssetOrigin::FontFile(ff) => write!(f, "font from `{}`", ff.source),
            }
        }
    }

    #[derive(Clone, Debug, Default, Deserialize, Serialize)]
    pub struct FontFileAssetData {
        /// The path to find the font file in the source stack.
        pub source: String,

        /// Variant glyphs that require us to emit alternate versions of the
        /// font file.
        pub vglyphs: HashMap<GlyphId, GlyphVariantMapping>,
    }

    /// Merge one table of variant glyph USV mappings into another.
    pub(crate) fn merge_vglyphs(
        cur: &mut HashMap<GlyphId, GlyphVariantMapping>,
        new: &HashMap<GlyphId, GlyphVariantMapping>,
    ) {
        // First, get the maximum seen index for each USV.

        let mut next_index = HashMap::new();

        for mapping in cur.values() {
            let idx = next_index.entry(mapping.usv).or_default();
            *idx = std::cmp::max(*idx, mapping.index + 1);
        }

        // Now add mappings for any new glyphs that we need.

        for (gid, mapping) in new {
            // If the glyph is already in the "cur" mapping, great. If not, add
            // a new mapping, using the "new" map's suggested USV.
            cur.entry(*gid).or_insert_with(|| {
                let next_idx = next_index.entry(mapping.usv).or_default();
                let index = *next_idx;
                *next_idx = index + 1;
                GlyphVariantMapping {
                    usv: mapping.usv,
                    index,
                }
            });
        }
    }

    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
    pub struct GlyphVariantMapping {
        /// The USV that the glyph should be mapped to
        pub usv: char,

        /// Which alternative-mapped font to use. These indices start at zero.
        pub index: usize,
    }

    impl From<crate::fontfile::GlyphAlternateMapping> for GlyphVariantMapping {
        fn from(m: crate::fontfile::GlyphAlternateMapping) -> Self {
            GlyphVariantMapping {
                usv: m.usv,
                index: m.alternate_map_index,
            }
        }
    }

    /// Map from symbolic family name to info about the fonts defining it.
    pub type FontEnsembleAssetData = HashMap<String, FontFamilyAssetData>;

    /// Merge one font ensemble (table of font-family definitions) into another.
    /// This can fail if the tables are not self-consistent.
    pub fn merge_font_ensembles(
        cur: &mut HashMap<String, FontFamilyAssetData>,
        new: &HashMap<String, FontFamilyAssetData>,
    ) -> Result<()> {
        for (name, new_ff) in new {
            if let Some(cur_ff) = cur.get_mut(name) {
                for (facetype, new_facepath) in &new_ff.faces {
                    if let Some(cur_facepath) = cur_ff.faces.get(&facetype) {
                        // This facetype is already defined in this family --
                        // check that we agree on what font it is.
                        if cur_facepath != new_facepath {
                            bail!(
                                "disagreeing origin paths for font family {}/{:?}: `{}` and `{}`",
                                name,
                                facetype,
                                cur_facepath,
                                new_facepath
                            );
                        }
                    } else {
                        // This facetype is new for this family.
                        cur_ff.faces.insert(*facetype, new_facepath.clone());
                    }
                }
            } else {
                // This family is a new definition. Just copy it.
                cur.insert(name.clone(), new_ff.clone());
            }
        }

        Ok(())
    }

    #[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
    pub struct FontFamilyAssetData {
        /// Map from face type to the output path of the font file providing it.
        pub faces: HashMap<FaceType, String>,
    }

    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
    pub enum FaceType {
        /// The regular (upright) font of a font family.
        Regular,

        /// The bold font of a family.
        Bold,

        /// The italic font of a family.
        Italic,

        /// The bold-italic font a current family.
        BoldItalic,
    }
}
